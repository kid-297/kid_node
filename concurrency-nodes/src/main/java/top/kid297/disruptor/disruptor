# disruptor 为何底层性能如此牛掰

- 数据结构层面：使用环形结构、数组、内存预加载
- 使用单线程写方式、内存屏障
- 消除为共享（填充缓存行）
- 序号栅栏和序号配合使用来消除锁和CAS


# 高性能之道 - 数据结构 - 内存预加载机制

- RingBuffer使用数组Object[] entries 作为存储元素

# 高性能之道 - 内核 - 使用单线程写

- Disruptor的RingBuffer，之所以可以做到完全无锁，也是因为“单线程写”，这是所有“前提的前提”
- 离开了这个前提条件，没有任何技术可以做到完全无锁
- Redis、Netty等等高性能技术框架的设计都是这个核心思想

# 高性能之道 - 系统内存优化 - 内存屏障

- 要正确的实现无锁，还需要另外一个关键技术：内存屏障
- 对应到Java语言，就是valotile变量与happens before语义。
- 内存屏障 - Linux的smp_wmb()/smp_rmb()

# 高性能之道 - 系统缓存优化 - 消除伪共享

- 缓存系统中是以缓存行为单位存储的
- 缓存行是2的整数幂个连续字节，一般为32-256个字节
- 最常见的缓存行大小是64个字节
- 当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响到彼此的性能，这就是伪共享。
- Sequence 使用左右填充技术，消除缓存行，空间换时间

# 高性能之道 - 算法优化 - 序号栅栏机制

- 我们在生产者投递Event的时候，总会使用
- long sequence = ringBuffer.next();
- Disruptor3.0中，序号栅栏SequenceBarrier和序号sequence搭配使用
- 协调和管理消费者与生产者的工作节奏，避免了锁和CAS的使用
- Disruptor3.0中，各个消费者和生产者持有自己的序号，这些序号的变化必须满足如下基本条件：
    - 消费者序号数值必须小于生产者序号数值
    - 消费者序号数值必须小于其前置（依赖关系）消费者的序号数值
    - 生产者序号数值不能大于消费者中最小的序号数值
    - 以避免生产者速度过快，将还未来得及消费的消息覆盖


